/*-------------------------------------------------------------------------------------------------
| This file is distributed under the MIT License.
| See accompanying file /LICENSE for details.
*------------------------------------------------------------------------------------------------*/
#pragma once

#include "../gates/gate.hpp"
#include "../networks/wire_id.hpp"

#include <cassert>
#include <tweedledee/dotqc/dotqc.hpp>

namespace tweedledum {

struct identify_gate {
	gate operator()(std::string_view gate_label)
	{
		switch (gate_label[0]) {
		case 'H':
			return gate_lib::h;

		case 'S':
		case 'P':
			if (gate_label.size() == 2 && gate_label[1] == '*') {
				return gate_lib::sdg;
			}
			return gate_lib::s;

		case 'T':
			if (gate_label.size() == 2 && gate_label[1] == '*') {
				return gate_lib::tdg;
			}
			return gate_lib::t;

		case 'X':
			return gate_lib::x;

		case 'Y':
			return gate_lib::y;

		case 'Z':
			// This will be a ugly hack (:
			if (gate_label.size() == 2 && gate_label[1] == 'd') {
				return gate_lib::opaque;
			}
			return gate_lib::z;

		default:
			break;
		}
		if (gate_label == "tof") {
			return gate_lib::x;
		}
		return gate_lib::undefined;
	}
};

template<typename Network>
class dotqc_reader : public tweedledee::dotqc_reader<gate> {
public:
	explicit dotqc_reader(Network& network)
	    : network_(network)
	{}

	void on_qubit(std::string_view name)
	{
		network_.create_qubit(name);
	}

	void on_gate(gate g, std::string_view target)
	{
		network_.create_op(g, target);
	}

	void on_gate(gate g, std::vector<std::string> const& controls,
	             std::vector<std::string> const& targets)
	{
		switch (g.id()) {
		case gate_ids::x:
			if (controls.size() == 1) {
				network_.create_op(gate_lib::cx, controls, targets);
				return;
			} else if (controls.size() >= 2) {
				network_.create_op(gate_lib::ncx, controls, targets);
				return;
			}
			break;

		case gate_ids::y:
			if (controls.size() == 1) {
				network_.create_op(gate_lib::cy, controls, targets);
				return;
			} else if (controls.size() >= 2) {
				network_.create_op(gate_lib::ncy, controls, targets);
				return;
			}
			break;

		case gate_ids::z:
			if (controls.size() == 1) {
				network_.create_op(gate_lib::cz, controls, targets);
				return;
			} else if (controls.size() >= 2) {
				network_.create_op(gate_lib::ncz, controls, targets);
				return;
			}
			break;

		// Hack to handle 'Zd' gate
		case gate_ids::opaque:
			network_.create_op(gate_lib::tdg, controls[0]);
			network_.create_op(gate_lib::tdg, controls[1]);
			network_.create_op(gate_lib::tdg, targets[0]);

			network_.create_op(gate_lib::cx, controls[0], controls[1]);
			network_.create_op(gate_lib::cx, controls[1], targets[0]);
			network_.create_op(gate_lib::cx, targets[0], controls[0]);

			network_.create_op(gate_lib::t, controls[0]);
			network_.create_op(gate_lib::t, controls[1]);
			network_.create_op(gate_lib::tdg, targets[0]);

			network_.create_op(gate_lib::cx, controls[1], controls[0]);
			network_.create_op(gate_lib::t, controls[0]);
			network_.create_op(gate_lib::cx, controls[1], targets[0]);
			network_.create_op(gate_lib::cx, targets[0], controls[0]);
			network_.create_op(gate_lib::cx, controls[0], controls[1]);
			return;

		default:
			break;
		}
		network_.create_op(g, controls, targets);
	}

private:
	Network& network_;
};

template<typename Network>
void read_dotqc_from_file(Network network, std::string_view path)
{
	dotqc_reader reader(network);
	dotqc_read(path, reader, identify_gate());
}

/*! \brief Reads dotQC format
 */
template<typename Network>
Network read_dotqc_from_file(std::string_view path)
{
	Network network;
	read_dotqc_from_file(network, path);
	return network;
}

/*! \brief Writes network in dotQC format into output stream
 *
 * An overloaded variant exists that writes the network into a file.
 *
 * \param network A quantum network
 * \param os Output stream
 */
template<typename Network>
void write_dotqc(Network const& network, std::ostream& os)
{
	using op_type = typename Network::op_type;
	os << fmt::format("# Generated by tweedledum\n");
	os << fmt::format(".v");
	network.foreach_wire([&](wire_id id, auto const& name) {
		if (id.is_qubit()) {
			os << fmt::format(" {}", name);
		}
	});
	os << fmt::format("\nBEGIN\n\n");
	network.foreach_op([&](op_type const& op) {
		switch (op.id()) {
		case gate_ids::h:
			os << fmt::format("H {}\n", network.wire_name(op.target()));
			break;

		case gate_ids::x:
			os << fmt::format("X {}\n", network.wire_name(op.target()));
			break;

		case gate_ids::y:
			os << fmt::format("Y {}\n", network.wire_name(op.target()));
			break;

		case gate_ids::z:
			os << fmt::format("Z {}\n", network.wire_name(op.target()));
			break;

		case gate_ids::s:
			os << fmt::format("S {}\n", network.wire_name(op.target()));
			break;

		case gate_ids::sdg:
			os << fmt::format("S* {}\n", network.wire_name(op.target()));
			break;

		case gate_ids::t:
			os << fmt::format("T {}\n", network.wire_name(op.target()));
			break;

		case gate_ids::tdg:
			os << fmt::format("T* {}\n", network.wire_name(op.target()));
			break;

		case gate_ids::cx:
		case gate_ids::ncx:
			os << fmt::format("X");
			op.foreach_control([&](wire_id c) {
				os << fmt::format(" {}", network.wire_name(c));
			});
			os << fmt::format(" {}\n", network.wire_name(op.target()));
			break;

		case gate_ids::cy:
		case gate_ids::ncy:
			os << fmt::format("Y");
			op.foreach_control([&](wire_id c) {
				os << fmt::format(" {}", network.wire_name(c));
			});
			os << fmt::format(" {}\n", network.wire_name(op.target()));
			break;

		case gate_ids::cz:
		case gate_ids::ncz:
			os << fmt::format("Z");
			op.foreach_control([&](wire_id c) {
				os << fmt::format(" {}", network.wire_name(c));
			});
			os << fmt::format(" {}\n", network.wire_name(op.target()));
			break;

		default:
			break;
		}
	});
	os << fmt::format("\nEND\n");
}

/*! \brief Writes network in dotQC format into a file
 *
 * \param network A quantum network
 * \param filename Filename
 */
template<typename Network>
void write_dotqc(Network const& network, std::string_view filename)
{
	std::ofstream os(filename, std::ofstream::out);
	write_dotqc(network, os);
}

} // namespace tweedledum
